<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Resizer & Converter</title>
<script src="https://cdn.tailwindcss.com/3.4.16"></script>
<script>tailwind.config={theme:{extend:{colors:{primary:'#4F46E5',secondary:'#10B981'},borderRadius:{'none':'0px','sm':'4px',DEFAULT:'8px','md':'12px','lg':'16px','xl':'20px','2xl':'24px','3xl':'32px','full':'9999px','button':'8px'}}}}</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css">
<style>
:where([class^="ri-"])::before { content: "\f3c2"; }
body {
font-family: 'Inter', sans-serif;
}
.dropzone {
border: 2px dashed #d1d5db;
transition: all 0.3s ease;
}
.dropzone.active {
border-color: #4F46E5;
background-color: rgba(79, 70, 229, 0.05);
}
.toast {
transform: translateY(100%);
transition: transform 0.3s ease;
}
.toast.show {
transform: translateY(0);
}
.progress-bar {
transition: width 0.3s ease;
}
.switch {
position: relative;
display: inline-block;
width: 44px;
height: 24px;
}
.switch input {
opacity: 0;
width: 0;
height: 0;
}
.slider {
position: absolute;
cursor: pointer;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-color: #ccc;
transition: .4s;
border-radius: 34px;
}
.slider:before {
position: absolute;
content: "";
height: 18px;
width: 18px;
left: 3px;
bottom: 3px;
background-color: white;
transition: .4s;
border-radius: 50%;
}
input:checked + .slider {
background-color: #4F46E5;
}
input:checked + .slider:before {
transform: translateX(20px);
}
</style>
</head>
<body class="bg-gray-50 min-h-screen">
<!-- Navigation Bar -->
<nav class="fixed w-full top-0 bg-white shadow-sm z-10">
<div class="px-4 py-3 flex items-center justify-between">
<h1 class="font-['Pacifico'] text-xl text-primary">logo</h1>
<button id="shareButton" class="flex items-center justify-center w-8 h-8 text-primary hover:bg-primary/10 rounded-full transition-colors">
<i class="ri-share-line"></i>
</button>
</div>
</nav>
<!-- Main Content -->
<main class="pt-16 pb-20 px-4">
<div class="mt-6 text-center">
<h1 class="text-2xl font-semibold text-gray-800">Image Resizer & Converter</h1>
<p class="text-gray-600 mt-2">Resize to 1280×1280 and convert to WebP format</p>
</div>
<!-- Upload Section -->
<div class="mt-8">
<div id="dropzone" class="dropzone rounded-xl p-8 flex flex-col items-center justify-center h-48 cursor-pointer">
<div class="w-16 h-16 flex items-center justify-center bg-primary/10 rounded-full mb-4">
<i class="ri-upload-cloud-line ri-xl text-primary"></i>
</div>
<p class="text-gray-700 font-medium">Tap to upload images</p>
<p class="text-gray-500 text-sm mt-2">or drop images here</p>
<p class="text-gray-400 text-xs mt-3">Accepted formats: JPG, PNG, GIF, BMP</p>
<input type="file" id="fileInput" class="hidden" accept="image/*" multiple>
</div>
<div id="imageList" class="mt-6 hidden">
<div class="flex justify-between items-center mb-4">
<h3 class="text-gray-700 font-medium">Selected Images</h3>
<span id="imageCount" class="text-sm text-gray-500">0 images</span>
</div>
<div class="space-y-3" id="imagePreviewList"></div>
</div>
</div>
<!-- Preview Section (Hidden initially) -->
<div id="previewSection" class="mt-10 hidden">
<div class="flex flex-col md:flex-row gap-6">
<!-- Original Image -->
<div class="flex-1 border border-gray-200 rounded-xl p-4 bg-white">
<h3 class="text-gray-700 font-medium mb-3">Original Image</h3>
<div class="relative aspect-square bg-gray-100 rounded-lg overflow-hidden flex items-center justify-center">
<img id="originalImage" class="max-w-full max-h-full object-contain" src="" alt="Original image">
</div>
<div class="mt-3 flex justify-between items-center">
<p id="originalDimensions" class="text-sm text-gray-600">0 × 0</p>
<p id="originalSize" class="text-sm text-gray-600">0 KB</p>
</div>
</div>
<!-- Arrow -->
<div class="flex justify-center items-center py-2">
<div class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-100">
<i class="ri-arrow-right-line ri-lg text-gray-500"></i>
</div>
</div>
<!-- Processed Image -->
<div class="flex-1 border border-gray-200 rounded-xl p-4 bg-white">
<h3 class="text-gray-700 font-medium mb-3">Processed Image</h3>
<div class="relative aspect-square bg-gray-100 rounded-lg overflow-hidden flex items-center justify-center">
<img id="processedImage" class="max-w-full max-h-full object-contain" src="" alt="Processed image">
<div id="processingOverlay" class="absolute inset-0 bg-white/80 flex flex-col items-center justify-center">
<div class="w-full max-w-[80%]">
<div class="h-2 bg-gray-200 rounded-full overflow-hidden">
<div id="progressBar" class="h-full bg-primary progress-bar w-0"></div>
</div>
<p class="text-sm text-gray-600 mt-2 text-center">Processing image...</p>
</div>
</div>
</div>
<div class="mt-3 flex justify-between items-center">
<p id="processedDimensions" class="text-sm text-gray-600">1280 × 1280</p>
<p id="processedSize" class="text-sm text-gray-600">0 KB</p>
</div>
</div>
</div>
</div>
<!-- Settings Panel -->
<div id="settingsPanel" class="mt-8 bg-white rounded-xl p-5 border border-gray-200 hidden">
<h3 class="text-gray-700 font-medium mb-4">Settings</h3>
<div class="space-y-4">
<!-- White Border Toggle -->
<div class="flex items-center justify-between">
<div>
<p class="text-gray-700">Add white borders if needed</p>
<p class="text-xs text-gray-500">Preserves aspect ratio with white padding</p>
</div>
<label class="switch">
<input type="checkbox" id="borderToggle" checked>
<span class="slider"></span>
</label>
</div>
<!-- Output Format -->
<div class="flex items-center justify-between">
<div>
<p class="text-gray-700">Output format</p>
<p class="text-xs text-gray-500">WebP offers better compression</p>
</div>
<div class="relative">
<select id="formatSelect" class="appearance-none bg-gray-100 rounded-button py-2 px-4 pr-8 text-gray-700 focus:outline-none focus:ring-2 focus:ring-primary">
<option value="webp" selected>WebP</option>
<option value="jpeg">JPEG</option>
<option value="png">PNG</option>
</select>
<div class="absolute right-2 top-1/2 transform -translate-y-1/2 pointer-events-none">
<i class="ri-arrow-down-s-line text-gray-500"></i>
</div>
</div>
</div>
<!-- Target Dimensions -->
<div class="flex items-center justify-between">
<div>
<p class="text-gray-700">Target dimensions</p>
<p class="text-xs text-gray-500">Maximum size for the output image</p>
</div>
<div class="bg-gray-100 rounded-button py-2 px-4 text-gray-700">
1280 × 1280
</div>
</div>
</div>
</div>
<!-- Action Buttons -->
<div id="actionButtons" class="mt-8 space-y-3 hidden">
<button id="processButton" class="w-full bg-primary text-white py-3 rounded-button font-medium shadow-sm hover:bg-primary/90 transition-colors !rounded-button">
Process Image
</button>
<button id="downloadButton" class="w-full bg-white border border-gray-300 text-gray-700 py-3 rounded-button font-medium shadow-sm hover:bg-gray-50 transition-colors !rounded-button hidden">
Download Image
</button>
<button id="resetButton" class="w-full bg-white text-gray-600 py-3 rounded-button font-medium hover:bg-gray-50 transition-colors !rounded-button">
Reset
</button>
</div>
<!-- Information Section -->
<div class="mt-10 bg-white rounded-xl p-5 border border-gray-200">
<h3 class="text-gray-700 font-medium mb-3">About This Tool</h3>
<div class="space-y-3 text-sm text-gray-600">
<p>This tool helps you resize images to 1280×1280 pixels and convert them to WebP format, which provides superior compression while maintaining quality.</p>
<p>All processing happens directly in your browser - your images are never uploaded to any server, ensuring complete privacy.</p>
<div class="flex items-start space-x-2 pt-2">
<i class="ri-information-line ri-lg text-primary mt-0.5"></i>
<p class="text-xs">WebP format may not be supported by all applications. If you need broader compatibility, choose JPEG or PNG format.</p>
</div>
</div>
</div>
</main>
<!-- Toast Notification -->
<div id="toast" class="fixed bottom-20 left-0 right-0 mx-auto w-[90%] max-w-sm bg-white rounded-xl shadow-lg border border-gray-200 p-4 toast">
<div class="flex items-start">
<div id="toastIcon" class="w-6 h-6 flex items-center justify-center rounded-full bg-green-100 mr-3">
<i class="ri-check-line text-green-500"></i>
</div>
<div class="flex-1">
<h4 id="toastTitle" class="font-medium text-gray-800">Success!</h4>
<p id="toastMessage" class="text-sm text-gray-600 mt-1">Your image has been processed successfully.</p>
</div>
<button id="closeToast" class="ml-4 text-gray-400 hover:text-gray-500">
<i class="ri-close-line"></i>
</button>
</div>
</div>
<!-- Tab Bar -->
<nav class="fixed bottom-0 w-full bg-white border-t border-gray-200 px-2 py-2">
<div class="grid grid-cols-3 gap-1">
<a href="#" class="flex flex-col items-center justify-center py-1 text-primary">
<div class="w-6 h-6 flex items-center justify-center">
<i class="ri-image-edit-line"></i>
</div>
<span class="text-xs mt-1">Resize</span>
</a>
<a href="#" class="flex flex-col items-center justify-center py-1 text-gray-500">
<div class="w-6 h-6 flex items-center justify-center">
<i class="ri-gallery-line"></i>
</div>
<span class="text-xs mt-1">Gallery</span>
</a>
<a href="#" class="flex flex-col items-center justify-center py-1 text-gray-500">
<div class="w-6 h-6 flex items-center justify-center">
<i class="ri-settings-3-line"></i>
</div>
<span class="text-xs mt-1">Settings</span>
</a>
</div>
</nav>
<!-- File Handling Script -->
<script id="fileHandlingScript">
document.addEventListener('DOMContentLoaded', function() {
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const previewSection = document.getElementById('previewSection');
const settingsPanel = document.getElementById('settingsPanel');
const actionButtons = document.getElementById('actionButtons');
const originalImage = document.getElementById('originalImage');
const originalDimensions = document.getElementById('originalDimensions');
const originalSize = document.getElementById('originalSize');
// Handle click on dropzone
dropzone.addEventListener('click', function() {
fileInput.click();
});
// Handle drag events
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
dropzone.addEventListener(eventName, preventDefaults, false);
});
function preventDefaults(e) {
e.preventDefault();
e.stopPropagation();
}
['dragenter', 'dragover'].forEach(eventName => {
dropzone.addEventListener(eventName, function() {
dropzone.classList.add('active');
}, false);
});
['dragleave', 'drop'].forEach(eventName => {
dropzone.addEventListener(eventName, function() {
dropzone.classList.remove('active');
}, false);
});
// Handle file drop
dropzone.addEventListener('drop', function(e) {
const dt = e.dataTransfer;
const files = dt.files;
if (files.length) {
handleFile(files[0]);
}
});
// Handle file selection
fileInput.addEventListener('change', function() {
if (this.files.length) {
handleFile(this.files[0]);
}
});
// Process the selected file
let selectedFiles = [];
function handleFile(files) {
selectedFiles = Array.from(files).filter(file => file.type.match('image.*'));
if (selectedFiles.length === 0) {
showToast('Error', 'Please select image files only.', 'error');
return;
}
const imageList = document.getElementById('imageList');
const imagePreviewList = document.getElementById('imagePreviewList');
const imageCount = document.getElementById('imageCount');
imagePreviewList.innerHTML = '';
imageCount.textContent = `${selectedFiles.length} images`;
selectedFiles.forEach((file, index) => {
const reader = new FileReader();
reader.onload = function(e) {
const previewItem = document.createElement('div');
previewItem.className = 'flex items-center justify-between bg-white p-3 rounded-xl border border-gray-200';
previewItem.innerHTML = `
<div class="flex items-center space-x-3">
<div class="w-12 h-12 rounded-lg bg-gray-100 flex items-center justify-center overflow-hidden">
<img src="${e.target.result}" class="w-full h-full object-cover" alt="Preview">
</div>
<div>
<p class="text-sm font-medium text-gray-700">${file.name}</p>
<p class="text-xs text-gray-500">${formatFileSize(file.size)}</p>
</div>
</div>
<button class="text-gray-400 hover:text-gray-500" onclick="removeImage(${index})">
<i class="ri-close-line"></i>
</button>
`;
imagePreviewList.appendChild(previewItem);
};
reader.readAsDataURL(file);
});
imageList.classList.remove('hidden');
settingsPanel.classList.remove('hidden');
actionButtons.classList.remove('hidden');
}
function removeImage(index) {
selectedFiles.splice(index, 1);
const imageCount = document.getElementById('imageCount');
imageCount.textContent = `${selectedFiles.length} images`;
if (selectedFiles.length === 0) {
document.getElementById('imageList').classList.add('hidden');
settingsPanel.classList.add('hidden');
actionButtons.classList.add('hidden');
}
const imagePreviewList = document.getElementById('imagePreviewList');
imagePreviewList.children[index].remove();
}
function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
});
</script>
<!-- Image Processing Script -->
<script id="imageProcessingScript">
document.addEventListener('DOMContentLoaded', function() {
const processButton = document.getElementById('processButton');
const downloadButton = document.getElementById('downloadButton');
const resetButton = document.getElementById('resetButton');
const originalImage = document.getElementById('originalImage');
const processedImage = document.getElementById('processedImage');
const processingOverlay = document.getElementById('processingOverlay');
const progressBar = document.getElementById('progressBar');
const processedDimensions = document.getElementById('processedDimensions');
const processedSize = document.getElementById('processedSize');
const borderToggle = document.getElementById('borderToggle');
const formatSelect = document.getElementById('formatSelect');
// Hide processing overlay initially
processingOverlay.style.display = 'none';
// Process image button click
processButton.addEventListener('click', async function() {
if (selectedFiles.length === 0) {
showToast('Error', 'Please upload images first.', 'error');
return;
}
// Show processing overlay
processingOverlay.style.display = 'flex';
progressBar.style.width = '0%';
try {
const processedFiles = [];
for (let i = 0; i < selectedFiles.length; i++) {
const file = selectedFiles[i];
const processedFile = await processImageFile(file);
processedFiles.push(processedFile);
// Update progress
const progress = ((i + 1) / selectedFiles.length) * 100;
progressBar.style.width = `${progress}%`;
}
// Create zip file
const zip = new JSZip();
processedFiles.forEach((file, index) => {
const fileName = `processed_${index + 1}.${formatSelect.value}`;
zip.file(fileName, file.split(',')[1], {base64: true});
});
const content = await zip.generateAsync({type: 'blob'});
const url = URL.createObjectURL(content);
// Update download button
downloadButton.classList.remove('hidden');
downloadButton.onclick = () => {
const link = document.createElement('a');
link.href = url;
link.download = 'processed_images.zip';
link.click();
URL.revokeObjectURL(url);
showToast('Success', 'Images downloaded successfully!', 'success');
};
processingOverlay.style.display = 'none';
showToast('Success', 'All images processed successfully!', 'success');
} catch (error) {
processingOverlay.style.display = 'none';
showToast('Error', 'Failed to process images.', 'error');
console.error(error);
}
// Show processing overlay
processingOverlay.style.display = 'flex';
progressBar.style.width = '0%';
// Simulate progress (in a real app, this would be based on actual processing)
let progress = 0;
const interval = setInterval(function() {
progress += 5;
progressBar.style.width = `${progress}%`;
if (progress >= 100) {
clearInterval(interval);
setTimeout(function() {
processImage();
}, 500);
}
}, 100);
});
// Reset button click
resetButton.addEventListener('click', function() {
// Reset everything
originalImage.src = '';
processedImage.src = '';
document.getElementById('previewSection').classList.add('hidden');
document.getElementById('settingsPanel').classList.add('hidden');
document.getElementById('actionButtons').classList.add('hidden');
downloadButton.classList.add('hidden');
originalDimensions.textContent = '0 × 0';
originalSize.textContent = '0 KB';
processedDimensions.textContent = '1280 × 1280';
processedSize.textContent = '0 KB';
document.getElementById('fileInput').value = '';
});
// Download button click
downloadButton.addEventListener('click', function() {
if (!processedImage.src) {
showToast('Error', 'No processed image to download.', 'error');
return;
}
// Create a temporary link and trigger download
const link = document.createElement('a');
link.download = `resized_image.${formatSelect.value}`;
link.href = processedImage.src;
link.click();
showToast('Success', 'Image downloaded successfully!', 'success');
});
// Process the image
function processImageFile(file) {
return new Promise((resolve, reject) => {
const img = new Image();
img.onload = function() {
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
// Target dimensions
const targetWidth = 1280;
const targetHeight = 1280;
// Calculate dimensions while maintaining aspect ratio
let width = img.width;
let height = img.height;
if (width > height) {
if (width > targetWidth) {
height = Math.round(height * (targetWidth / width));
width = targetWidth;
}
} else {
if (height > targetHeight) {
width = Math.round(width * (targetHeight / height));
height = targetHeight;
}
}
// Set canvas size
if (borderToggle.checked) {
// With white borders
canvas.width = targetWidth;
canvas.height = targetHeight;
// Fill with white
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Center the image
const x = (targetWidth - width) / 2;
const y = (targetHeight - height) / 2;
ctx.drawImage(img, x, y, width, height);
} else {
// Without borders, just resize
canvas.width = width;
canvas.height = height;
ctx.drawImage(img, 0, 0, width, height);
}
// Convert to selected format
const format = formatSelect.value;
let quality = 0.9;
let mimeType;
switch (format) {
case 'webp':
mimeType = 'image/webp';
quality = 0.8;
break;
case 'jpeg':
mimeType = 'image/jpeg';
break;
case 'png':
mimeType = 'image/png';
break;
default:
mimeType = 'image/webp';
}
// Get processed image data
const dataUrl = canvas.toDataURL(mimeType, quality);
resolve(dataUrl);
};
img.onerror = reject;
const reader = new FileReader();
reader.onload = (e) => {
img.src = e.target.result;
};
reader.onerror = reject;
reader.readAsDataURL(file);
});
}
function processImage() {
const img = new Image();
img.onload = function() {
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
// Target dimensions
const targetWidth = 1280;
const targetHeight = 1280;
// Calculate dimensions while maintaining aspect ratio
let width = img.width;
let height = img.height;
if (width > height) {
if (width > targetWidth) {
height = Math.round(height * (targetWidth / width));
width = targetWidth;
}
} else {
if (height > targetHeight) {
width = Math.round(width * (targetHeight / height));
height = targetHeight;
}
}
// Set canvas size
if (borderToggle.checked) {
// With white borders
canvas.width = targetWidth;
canvas.height = targetHeight;
// Fill with white
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Center the image
const x = (targetWidth - width) / 2;
const y = (targetHeight - height) / 2;
ctx.drawImage(img, x, y, width, height);
} else {
// Without borders, just resize
canvas.width = width;
canvas.height = height;
ctx.drawImage(img, 0, 0, width, height);
}
// Convert to selected format
const format = formatSelect.value;
let quality = 0.9;
let mimeType;
switch (format) {
case 'webp':
mimeType = 'image/webp';
quality = 0.8; // WebP can use lower quality due to better compression
break;
case 'jpeg':
mimeType = 'image/jpeg';
break;
case 'png':
mimeType = 'image/png';
break;
default:
mimeType = 'image/webp';
}
// Get processed image data
const dataUrl = canvas.toDataURL(mimeType, quality);
processedImage.src = dataUrl;
// Update dimensions
processedDimensions.textContent = `${canvas.width} × ${canvas.height}`;
// Estimate file size (this is approximate)
const base64 = dataUrl.split(',')[1];
const binarySize = window.atob(base64).length;
processedSize.textContent = formatFileSize(binarySize);
// Hide overlay and show download button
processingOverlay.style.display = 'none';
downloadButton.classList.remove('hidden');
showToast('Success', 'Image processed successfully!', 'success');
};
img.src = originalImage.src;
}
function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
});
</script>
<!-- Share Link Modal -->
<div id="shareModal" class="fixed inset-0 bg-black/50 z-50 hidden">
<div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[90%] max-w-sm bg-white rounded-xl p-5">
<div class="flex justify-between items-center mb-4">
<h3 class="text-lg font-medium text-gray-800">Share Link</h3>
<button id="closeShareModal" class="text-gray-400 hover:text-gray-500">
<i class="ri-close-line"></i>
</button>
</div>
<div class="space-y-4">
<div>
<label class="block text-sm font-medium text-gray-700 mb-1">Private Link</label>
<div class="relative">
<input type="text" id="shareLink" readonly class="w-full bg-gray-50 border border-gray-200 rounded-button py-2 px-3 pr-10 text-gray-700" value="">
<button id="copyLink" class="absolute right-2 top-1/2 transform -translate-y-1/2 w-6 h-6 flex items-center justify-center text-gray-500 hover:text-primary">
<i class="ri-file-copy-line"></i>
</button>
</div>
</div>
<div class="flex items-start space-x-2">
<i class="ri-information-line text-primary mt-1"></i>
<p class="text-xs text-gray-600">This link allows anyone to access your image processing tool. For security, you can generate a new link anytime.</p>
</div>
<div class="flex justify-end space-x-3 mt-6">
<button id="generateNewLink" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-button hover:bg-gray-200 transition-colors !rounded-button">Generate New</button>
<button id="confirmShare" class="px-4 py-2 bg-primary text-white rounded-button hover:bg-primary/90 transition-colors !rounded-button">Done</button>
</div>
</div>
</div>
</div>
<!-- Toast Notification Script -->
<script id="toastScript">
document.addEventListener('DOMContentLoaded', function() {
const toast = document.getElementById('toast');
const shareButton = document.getElementById('shareButton');
const shareModal = document.getElementById('shareModal');
const closeShareModal = document.getElementById('closeShareModal');
const shareLink = document.getElementById('shareLink');
const copyLink = document.getElementById('copyLink');
const generateNewLink = document.getElementById('generateNewLink');
const confirmShare = document.getElementById('confirmShare');
function generateUniqueLink() {
const uniqueId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
return `${window.location.origin}/share/${uniqueId}`;
}
function showShareModal() {
shareModal.classList.remove('hidden');
if (!shareLink.value) {
shareLink.value = generateUniqueLink();
}
}
function hideShareModal() {
shareModal.classList.add('hidden');
}
function copyToClipboard() {
shareLink.select();
document.execCommand('copy');
showToast('Success', 'Link copied to clipboard!', 'success');
}
shareButton.addEventListener('click', showShareModal);
closeShareModal.addEventListener('click', hideShareModal);
confirmShare.addEventListener('click', hideShareModal);
copyLink.addEventListener('click', copyToClipboard);
generateNewLink.addEventListener('click', function() {
shareLink.value = generateUniqueLink();
showToast('Success', 'New link generated!', 'info');
});
shareModal.addEventListener('click', function(e) {
if (e.target === shareModal) {
hideShareModal();
}
});
const toastTitle = document.getElementById('toastTitle');
const toastMessage = document.getElementById('toastMessage');
const toastIcon = document.getElementById('toastIcon');
const closeToast = document.getElementById('closeToast');
window.showToast = function(title, message, type = 'success') {
toastTitle.textContent = title;
toastMessage.textContent = message;
// Set icon based on type
if (type === 'success') {
toastIcon.innerHTML = '<i class="ri-check-line text-green-500"></i>';
toastIcon.className = 'w-6 h-6 flex items-center justify-center rounded-full bg-green-100 mr-3';
} else if (type === 'error') {
toastIcon.innerHTML = '<i class="ri-error-warning-line text-red-500"></i>';
toastIcon.className = 'w-6 h-6 flex items-center justify-center rounded-full bg-red-100 mr-3';
} else if (type === 'info') {
toastIcon.innerHTML = '<i class="ri-information-line text-blue-500"></i>';
toastIcon.className = 'w-6 h-6 flex items-center justify-center rounded-full bg-blue-100 mr-3';
}
// Show toast
toast.classList.add('show');
// Auto hide after 3 seconds
setTimeout(function() {
hideToast();
}, 3000);
};
function hideToast() {
toast.classList.remove('show');
}
// Close button
closeToast.addEventListener('click', hideToast);
});
</script>
</body>
</html>
